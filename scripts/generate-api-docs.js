#!/usr/bin/env node
// generate-api-docs.js
import swaggerJsdoc from 'swagger-jsdoc';
import yaml from 'js-yaml';
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

// Get the directory name using ES module syntax
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const baseDir = path.resolve(__dirname, '..');

// Parse command line arguments
const args = process.argv.slice(2);
let outputFile = 'api-docs.yaml';
let baseRoutePath = null;
let shouldImport = false;
let orgName = 'demo-org';
let clientName = 'LuminaireAPI';

// Process command line arguments
for (let i = 0; i < args.length; i++) {
  if (args[i] === '--output' && args[i + 1]) {
    outputFile = args[i + 1];
    i++;
  } else if (args[i] === '--only' && args[i + 1]) {
    baseRoutePath = args[i + 1];
    i++;
  } else if (args[i] === '--import') {
    shouldImport = true;
  } else if (args[i] === '--org' && args[i + 1]) {
    orgName = args[i + 1];
    i++;
  } else if (args[i] === '--name' && args[i + 1]) {
    clientName = args[i + 1];
    i++;
  }
}

// We need a different approach for Fastify apps that use schema-based route definitions instead of JSDoc
// Read the existing OpenAPI spec file that's already generated by the running server
let existingSpec = {};
try {
  const existingSpecPath = path.join(baseDir, 'api-docs-full.yaml');
  if (fs.existsSync(existingSpecPath)) {
    console.log(`Reading existing OpenAPI spec from ${existingSpecPath}...`);
    const specFileContent = fs.readFileSync(existingSpecPath, 'utf8');
    existingSpec = yaml.load(specFileContent);
  } else {
    console.log(
      'No existing OpenAPI spec found. Using default configuration...'
    );
  }
} catch (error) {
  console.error('Error reading existing OpenAPI spec:', error.message);
}

// Define base options for OpenAPI spec
const options = {
  definition: {
    openapi: '3.0.3',
    info: {
      title: existingSpec.info?.title || 'Luminaire Solar API',
      description:
        existingSpec.info?.description ||
        'Provides access to the Luminaire Solar API',
      version: existingSpec.info?.version || '1.0',
    },
    servers: existingSpec.servers || [
      {
        url: 'http://localhost:3000',
        description: 'Local development server',
      },
      {
        url: 'https://luminaire-solar-api.herokuapp.com',
        description: 'Heroku production server',
      },
    ],
    components: existingSpec.components || {
      securitySchemes: {
        BearerAuth: {
          description: 'RSA256 JWT signed by secret key, with user in payload',
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    // If we have existing paths, use them
    paths: existingSpec.paths || {},
    tags: existingSpec.tags || [],
  },
  // Path to the API files relative to the base directory (only used if we're using JSDoc annotations)
  apis: [
    path.join(baseDir, 'routes/*.js'),
    path.join(baseDir, 'plugins/*.js'),
    path.join(baseDir, 'schemas/*.js'),
  ],
};

// If we have an existing spec with paths, use that; otherwise try to generate from JSDoc
let outputSpec;

if (Object.keys(existingSpec.paths || {}).length > 0) {
  console.log('Using existing OpenAPI specification from file...');
  outputSpec = existingSpec;
} else {
  console.log('Generating OpenAPI specification from JSDoc comments...');
  outputSpec = swaggerJsdoc(options);
}

// Optionally filter paths by base route
let filteredSpec = { ...outputSpec };
if (baseRoutePath) {
  console.log(
    `Filtering routes to include only those starting with: ${baseRoutePath}`
  );
  filteredSpec.paths = Object.keys(outputSpec.paths || {})
    .filter((path) => path.startsWith(baseRoutePath))
    .reduce((obj, key) => {
      obj[key] = outputSpec.paths[key];
      return obj;
    }, {});
}

// Transform the OpenAPI spec to hide non-API routes
Object.keys(filteredSpec.paths || {}).forEach((url) => {
  if (!url.startsWith('/api')) {
    if (!filteredSpec.paths[url].hide) {
      filteredSpec.paths[url].hide = true;
    }
  }
});

// Convert to YAML
const yamlString = yaml.dump(filteredSpec);

// Create directory if it doesn't exist
const outputDir = path.dirname(outputFile);
if (outputDir !== '.' && !fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Write to output file (use absolute path if not already absolute)
const outputPath = path.isAbsolute(outputFile)
  ? outputFile
  : path.join(process.cwd(), outputFile);
fs.writeFileSync(outputPath, yamlString, 'utf8');
console.log(`Generated OpenAPI YAML file: ${outputPath}`);

// Optionally import to Salesforce
if (shouldImport) {
  try {
    console.log(`Importing to Salesforce org ${orgName} as ${clientName}...`);
    const result = execSync(
      `heroku salesforce:import ${outputPath} --org-name ${orgName} --client-name ${clientName}`,
      { encoding: 'utf8' }
    );
    console.log(result);
  } catch (error) {
    console.error('Error importing to Salesforce:', error.message);
  }
}
